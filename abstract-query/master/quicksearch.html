<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" abstract-query Classes ComparatorParamQueryQueryFormatterRange Global $DEFAULT_ORDERFACTORY_HANDLERisComparable Global Members &lt;constant&gt; $ Proxied factory. Factory. is equivalent to Param.from(&quot;&quot;) &lt;constant&gt; FACTORY_HANDLER Proxy handler for factory. Methods DEFAULT_ORDER(a, b) Default comparator. Parameters: Name Type Description a first parameter b second parameter Returns: a &lt; b isComparable(object) Return true if object is one of the comparable types Parameters: Name Type Description object object to test Returns: true if object is comparable (@see Comparable) Type Definitions Comparable Types on which comparison operators are valid. Type: number | string | boolean | Date × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" abstract-query Classes ComparatorParamQueryQueryFormatterRange Global $DEFAULT_ORDERFACTORY_HANDLERisComparable Classes Classes Comparator Param Query QueryFormatter Range × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" abstract-query Classes ComparatorParamQueryQueryFormatterRange Global $DEFAULT_ORDERFACTORY_HANDLERisComparable Abstract QueryAbstract query, providing for client-side optimisation of queries. Example let query = Query .from({ course: 'javascript 101', student: { age : [21,] }, grade: [,'C'] }).or({ course: 'medieval French poetry', student: { age: [40,65]}, grade: [,'C'] }) let expr = query.toExpression();and expression should equal: grade&lt;&quot;C&quot; and (course=&quot;javascript 101&quot; and (student.age&gt;=21) or course=&quot;medieval French poetry&quot; and (student.age&gt;=40 and student.age&lt;65)) Note that the common expression grade&lt;&quot;C&quot; has been factored out of the 'or'. Plainly that's not all that much use in this simple example but when programatically constructing complex queries it is extremely useful to ensure that the query that ultimately sent to the data store is reasonably concise. Expression FormattersThe toExpression method takes a formatter object so that query objects can be used to create any kind of output. For example: const formatter = { andExpr(...ands) { return ands.join(' &amp;&amp; ') }, orExpr(...ors) { return &quot;(&quot; + ors.join(' || ') + &quot;)&quot;}, operExpr(dimension, operator, value, context) { return (operator === 'contains') ? dimension&quot;[&quot; + value + &quot;]&quot; : dimension + operator +value } let expr = query.toExpression(formatter)Will result in an expr like: grade&lt;&quot;C&quot; &amp;&amp; (course=&quot;javascript 101&quot; &amp;&amp; student[age&gt;=&quot;21&quot;] || course=&quot;medieval French poetry&quot; &amp;&amp; student[age&gt;=&quot;40&quot; &amp;&amp; age&lt;&quot;65&quot;]) The objective is to provide several different expression formatters, to support (at a minumum) constructing suitable expressions for IndexedDB, MongoDB, and MySQL. These formatters will be provided in separate packages so that a code can be written to the abstract-query API without creating a dependency on any given back-end store. Filtering Arrays and IterablesAbstract Query itself provides a simple 'predicate' property that can be used to filter arrays. For example: let data = [ { name: 'jonathan', age: 12}, { name: 'cindy', age: 18}, { name: 'ada', age: 21} ]; let query = Query.from({ age: [,18]}); let result = data.filter(query.predicate);Will filter all the items with age less than 18 from the given data array. While the query API offers little advantage over an anonymous predicate function in this simple example, the ability to compose, optimise, and parametrize queries is a significant benefit in more complex cases. As more expression formatters are built, the ability to use a single query format across native data structures, front-end data stores, and back-end data stores will provide significant benefits to code readability and portability. ParametersOf course, abstract query also supports parametrized queries. let query = Query .from({ course: 'javascript 101', student: { age : [$.min_age,] }, grade: [,'C']}) .or({ course: 'medieval French poetry', student: { age: [$.min_age, 65]}, grade: [,'C']}) let expr = query.toExpression();Will result in an expr like: grade&lt;&quot;C&quot; and (course=&quot;javascript 101&quot; and (student.age&gt;=$min_age) or course=&quot;medieval French poetry&quot; and (student.age&gt;=$min_age and student.age&lt;65)) Parameters can be bound to create a new query, thus given the query above: let expr2 = query .bind({min_age: 27}) .toExpression();Will result in an expr like: grade&lt;&quot;C&quot; and (course=&quot;javascript 101&quot; and (student.age&gt;=27) or course=&quot;medieval French poetry&quot; and (student.age&gt;=27 and student.age&lt;65)) The library re-optimises the query when parameters are bound, and also tries quite hard to indentify redundant or mutually exclusive criteria even if a query is parametrised. Subqueries and Child ObjectsSubqueries can be used to put conditions on sub-properties. In the below example, the subquery 'expertise_query' is used to pick items in the data array which have an object in 'expertise' which has a language property of 'java'. let data = [ { name: 'jonathan', age: 45 expertise: [ { language:'java', level:'expert' }, { language:'javascript', level:'novice' } ] }, ...other entries... ]; let expertise_query = Query.from({ language:'java' }); let result = data.filter(Query .from({ age: [,50], expertise: expertise_query }) .predicate );Note that it is not necessary to create a subquery as a separate object, the final query could have been written Query.from({ age: [,50], expertise: { language:'java' }}) with identical effect. Subquery syntax can also be used to filter on properties that are not arrays (for example, the code above would work unchanged if 'expertise' was not an array but a simple object containing language and level properties). CachingAbstract query will also aid in building any kind of caching layer. Because abstract-query actually stores the query in an internal canoncial form, two queries can be compared for equality even if they are outwardly somewhat different. Thus: let query1 = Query.from({x: [,2], y: { alpha: [2,6], beta: { nuts: 'brazil' }}}); let query2 = Query.from({y: { beta: { nuts: 'brazil' }, alpha: [2,6]}, x: [,2]}); let query3 = query1.and(query2); let query4 = query2.and(query1); query1.equals(query2) // true query3.equals(query4) // trueEven better, query.contains allows you to detect whether one query is a subset of another; thus data can be potentially be retrieved by just filtering an existing cached result set rather than requerying the data store for data we already have. For the latest API documentation see The Software Plumbers Site Project StatusBeta. The API is stabilising, and although unit test coverage could be better it seems broadly functional. We are building downstream code (the above-mentioned formatters, for example). × Search results Close "},"Comparator.html":{"id":"Comparator.html","title":"Class: Comparator","body":" abstract-query Classes ComparatorParamQueryQueryFormatterRange Global $DEFAULT_ORDERFACTORY_HANDLERisComparable Class: Comparator Comparator Utility class - help compare values new Comparator(simple) Parameters: Name Type Description simple Range~OrderingFunction comparison function Methods &lt;static&gt; params() Returns: true if a or b is a parameter &lt;static&gt; paramsEqual() Returns: true if a and b are both the same parameter equals() Returns: true if a = b or a and b are both the same parameter, null if either is a parameter and they are not equal, false otherwise Type boolean greaterThan() Returns: true if a &gt; b or null if a or b is a parameter Type boolean greaterThanOrEqual() Returns: true if a &lt;= b or a and b are both the same parameter, null if either is a parameter and they are not equal, false otherwise Type boolean lessThan() Returns: true if a &lt; b or null if a or b is a parameter Type boolean lessThanOrEqual() Returns: true if a &gt;= b or a and b are both the same parameter, null if either is a parameter and they are not equal, false otherwise Type boolean × Search results Close "},"Param.html":{"id":"Param.html","title":"Class: Param","body":" abstract-query Classes ComparatorParamQueryQueryFormatterRange Global $DEFAULT_ORDERFACTORY_HANDLERisComparable Class: Param Param Class representing a query parameter than can be set later. new Param(name) Create a new query parameter Parameters: Name Type Description name string the name of the query parameter Methods &lt;static&gt; from(name) Create a new query parameter Parameters: Name Type Description name string | ParamObject the name of the query parameter &lt;static&gt; isParam(obj) Check in an object is a paramter Parameters: Name Type Description obj Object object to check Returns: true of obj is a Param equals(other) Compare parameters Parameters are considered equal if their names are equal. Parameters: Name Type Description other Param parameter to compare to this one Returns: true if other.name equals this.name; false otherwise. toString() Convert parameter to a string Returns: the parameter name, prefixed with a '$' symbol. Type Definitions ParamObject Type: Object Properties: Name Type Description $ string the name of the parameter × Search results Close "},"Query.html":{"id":"Query.html","title":"Class: Query","body":" abstract-query Classes ComparatorParamQueryQueryFormatterRange Global $DEFAULT_ORDERFACTORY_HANDLERisComparable Class: Query Query A Query represent an arbitrary set of constraints on a set of data. A constraint, in this case, is a mapping of a field name (or dimension) to a Range object. A query can be created from a constraint object which is simply an object with a number of properties, where the name of each property is the field name and the value is a Range (or something that can be converted into a range with Range.from). Once a query has been created, it can be combined with other queries or constraint objects using the and and or methods. A query can be converted into an expression using the toExpression method, which uses the provided callbacks to construct an expression in the desired syntax. The internal query representation is a 'canonical form' composed of a flat sequence of 'ands' joined by 'ors'. Given queries a,b,c,d the internal representation of (a.or(b)).and(c.or(d)) will actually be something like a.and(c).or(a.and(d)).or(b.and(c)).or(b.and(d)). The optimize method can work on this internal representation to remove redundant criteria. The toExpression method attempts to remove common factors from the internal representation before generating an expression. Calling a.and(c).or(a.and(d)).toExpression(...) with appropriate callbacks should generate an expression like a and (c or d) instead of (a and c) or (a and d). new Query(cubes) Construct a query from an array of cube objects. Should be considered a private constructor - use from instead to create a query. Parameters: Name Type Description cubes Array.&lt;Cube&gt; An array of cubes. Members &lt;static&gt; DEFAULT_FORMAT Get the default query formatter predicate Convenience property for filtering Given a query, query.predicate is equal to item=&gt;this.contains(item); @ returns {Function} a function that returns true if its parameter is matched by this query. Methods &lt;static&gt; from(obj) Create a query from an constraint object The constraint object can have any number of properties. In the following example, the resulting query applies all the following constraints: w &gt;= 3, x == 3, y &gt;= 3, y &lt; 7, z &lt; 7 Parameters: Name Type Description obj Query~ConstraintObject A constraint object. Returns: a Query Example 1 * Query.from({ w: [3,], x : 3, y : [3,7], z: [,7]}) and(obj) Create a new query that will return the union of results in this query and with some other query or constraint. Parameters: Name Type Description obj Query | Query~ConstraintObject the other query or constraint Returns: a new compound query that is the union of result sets Type Query andConstraint(other_constraint) Create a new query that will return results in this query that also comply with some other constraint. Parameters: Name Type Description other_constraint Query~ConstraintObject Returns: a new compound query. Type Query andQuery(other_query) Create a new query that will return the intersection of results in this query and some other query. Parameters: Name Type Description other_query Query the other query Returns: a new compound query that is the intersection of result sets from both queries Type Query bind(parameter) Bind a set of paramters to a query. Property values from the parameters object are used to fill in values for any parameters that this query was created. So: Query .from({ height : [$.floor, $.ceiling]}) .bind({ floor:12, ceiling: 16}) .toExpression();will return something like height &gt;= 12 and height &lt; 16. Parameters: Name Type Description parameter Object values Returns: new query, with parameter values set. Type Query contains(obj) Establish if this results of this query would be a superset of the given constraint or query. Containment may be indeterminate one or more of the queries/constraints involved is parametrized and containment cannot be determined until the parameter values are known. However, the library works quite hard to identify cases where containment can be determined even if the query is parametrized. For example: Query.from({ height: [$.param1, 12]}).contains(Query.from{ height[13, $.param2]})will return false since the two ranges can never overlap even though they are parametrized. Parameters: Name Type Description obj Query~ConstraintObject | Query the constraint or query Returns: true if obj is a subset of this query, false if it isn't, null if containment is indeterminate containsConstraint(constraint) Establish if this results of this query would be a superset of the given constraint. Parameters: Name Type Description constraint Query~ConstraintObject the constraint Returns: true if constraint is a subset of this query, false if it isn't, null if containment is indeterminate containsItem(item) Establish if a specific data item should be in the results of this query Very similar to contains. For an 'item' with simple properties, the result should be identical. However an object provided to contains is assumed to be a constraint, so properties with array/object values are processed as ranges. An item provided to 'containsItem' is an individual data item to test, so array and object properties are not processed as ranges. Parameters: Name Type Description item to test Returns: true, false or null containsQuery(other_query) Establish if this results of this query would be a superset of the given query. Parameters: Name Type Description other_query Query the other query Returns: true if other query is a subset of this one, false if it isn't, null if containment is indeterminate equals(obj) Establish if this results of this query would be a superset of the given constraint or query. Parameters: Name Type Description obj Query~ConstraintObject | Query the constraint or query Returns: true if obj is a subset of this query. equalsConstraint(constraint) Establish if this results of this query would be the same as for a query created from the given constraint. Parameters: Name Type Description constraint Query~ConstraintObject the constraint Returns: true if constraint is the same as this query. equalsQuery(other_query) Establish if this result of this query is the same as the given query. Parameters: Name Type Description other_query Query the other query Returns: true if other query is a subset of this one. factor(constraint) Attempt to simplify a query by removing a common factor from the canonical form. Given something like: let query = Query .from({x: 2, y : [3,4], z : 8}) .or({x:2, y: [,4], z: 7}) .or({x:3, y: [3,], z: 7}); let { factored, remainder } = query.factor({ x: 2});factored should equal Query.from({y : [3,4], z : 8}).or({y: [,4], z: 7}) and remainder should equal Query.from({x:3, y: [3,], z: 7}) Parameters: Name Type Description constraint ConstraintObject object to factor out of query Returns: Type Query~FactorResult findFactor() Find the factor that is common to the largest number of sub-expressions in canonical form. Returns: A constraint object containing the common factor, or undefined. Type Object optimize() Delete any redundant critera from the query or(obj) Create a new query that will return the union of results in this query and with some other query or constraint. Parameters: Name Type Description obj Query | Query~ConstraintObject the other query or constraint Returns: a new compound query that is the union of result sets Type Query orConstraint(other_constraint) Create a new query that will return the union of results in this query with some other constraint. Parameters: Name Type Description other_constraint Query~ConstraintObject Returns: a new compound query. Type Query orQuery(other_query) Create a new query that will return the union of results in this query and with some other query. Parameters: Name Type Description other_query Query the other query Returns: a new compound query that is the union of result sets from both queries Type Query toExpression( [formatter] [, context]) Convert a query to a an expression. Parameters: Name Type Argument Default Description formatter QueryFormatter &lt;optional&gt; Query~DEFAULT_FORMATTER Generates expressions from element of a query context Context &lt;optional&gt; context information Returns: expression - result expression. Typically a string but can be any type. Type Expression Type Definitions ConstraintObject A set of constraints. An object with properties names that represent field names on which a constraint is applied, and property values represent a constraint. The constraint may be a simple comparable value, a Range object, or an array with a maximum of two elements representing the lower and upper bounds of a constraint. Type: Object.&lt;string, (Range|Array.&lt;Comparable&gt;|Comparable)&gt; FactorResult Type: Object Properties: Name Type Description factored Query the part of the query from which a factor has been removed remainder Query the part of the query from which a factor could not be removed × Search results Close "},"QueryFormatter.html":{"id":"QueryFormatter.html","title":"Class: QueryFormatter","body":" abstract-query Classes ComparatorParamQueryQueryFormatterRange Global $DEFAULT_ORDERFACTORY_HANDLERisComparable Class: QueryFormatter QueryFormatter Interface for converting queries to expressions new QueryFormatter() Methods andExpr(subexpressions) Convert a number of sub-expressions into an 'and' expression Parameters: Name Type Argument Description subexpressions QueryFormatter~Expression &lt;repeatable&gt; subexpressions from which compound expression is built Returns: an 'and' expression. Type QueryFormatter~Expression operExpr(dimension, operator, value, context) Convert a number of sub-expressions into an 'and' expression Parameters: Name Type Description dimension string property or field name on which constraint operates operator string the constraint operatoer value QueryFormatter~Expression | Comparable the value for comparison context QueryFormatter~Context for subqueries, contains chain of parent dimension names Returns: an operator expression. Type QueryFormatter~Expression orExpr(subexpressions) Convert a number of sub-expressions into an 'or' expression Parameters: Name Type Argument Description subexpressions QueryFormatter~Expression &lt;repeatable&gt; subexpressions from which compound expression is built Returns: an 'or' expression. Type QueryFormatter~Expression Type Definitions Context Context information for subqueries Type: Object Properties: Name Type Description dimension string name of parent property context QueryFormatter~Context parent context. Expression The result of formatting a query - can be any type, but all the methods of QueryFormatter should all return the same type. Often a String. Type: Object × Search results Close "},"Range.html":{"id":"Range.html","title":"Class: Range","body":" abstract-query Classes ComparatorParamQueryQueryFormatterRange Global $DEFAULT_ORDERFACTORY_HANDLERisComparable Class: Range Range Range is an abstract class representing a range of values. Objects extending range should implement 'contains', 'intersect', 'equals', and 'bind' operations. Not all ranges are necessarily continuous (like dates/times) or numeric. A Range may also represent a node in a directed graph - in which case 'contains' may mean 'is a parent of' and 'intersect' may mean 'common subtree'. Range also provides a number of static functions that construct new instances of Range (or usually of some subclass of range). new Range() Members &lt;static&gt; OPERATORS Object mapping of range operators to constructor functions Operator String Constructor Function &quot;&gt;&quot; Range.greaterThan &quot;&lt;&quot; Range.LessThan &quot;&gt;=&quot; Range.greaterThanOrEqual &quot;&lt;=&quot; Range.lessThanOrEqual &quot;=&quot; Range.equal &quot;$and&quot; Range.and &lt;static&gt; UNBOUNDED Provide access to global Unbounded range Methods &lt;static&gt; and(ranges [, order]) Create a range containing values in all the given ranges TODO: consider if this needs to support Between parameters. Parameters: Name Type Argument Default Description ranges Array.&lt;Range~AnyValue&gt; order Range~OrderingFunction &lt;optional&gt; DEFAULT_ORDER compare two values and return true if the first is less than the second. Returns: a Range object Type Range &lt;static&gt; between(lower, upper [, order]) Create a range containing values between the given values Parameters: Name Type Argument Default Description lower Range~BetweenValue lower range boundary (inclusive by default) upper Range~BetweenValue upper range boundary (exclusive by default) order Range~OrderingFunction &lt;optional&gt; DEFAULT_ORDER compare two values and return true if the first is less than the second. Returns: a Range object Type Range &lt;static&gt; equals(value [, order]) Create a range containing a single value Parameters: Name Type Argument Default Description value Range~SimpleValue value to search for order Range~OrderingFunction &lt;optional&gt; DEFAULT_ORDER compare two values and return true if the first is less than the second. Returns: a Range object Type Range &lt;static&gt; from(bounds [, order]) Create a range. Specified bounds may be an array, or any object supported by Range.fromValue Type Result Range~BetweenValue[] [a,b] -&gt; Range.between(Range.fromBounds(a,Range.greaterThanOrEqual, order), Range.fromBounds(b,Range.lessThan, order)) Range~AnyValue Range.fromValue(object) Parameters: Name Type Argument Default Description bounds Range~AnyValue | Array.&lt;Range~BetweenValue&gt; bounding values for range order Range~OrderingFunction &lt;optional&gt; DEFAULT_ORDER compare two values and return true if the first is less than the second. Returns: a range, or undefined if paramters are not compatible. Type Range &lt;static&gt; fromBounds(obj) Create a range from a bounds object Parameters: Name Type Description obj Range~Bounds Returns: a range if obj is a bounds object, null otherwise Type Range &lt;static&gt; fromValue(obj [, default_constructor] [, order]) Create a range from a single value The parameter 'obj' may be a bounds object, a simple value, a parameter a Query, or a Range. The result varies according to the type of obj, and whether an explicit order function is provided. Type of obj order Result null null undefined undefined Range obj Query Range.subquery(obj) Range~Bounds Range.fromBounds(obj) Param default_constructor(obj, order) Param~ParamObject default_constructor(Param.from(obj), order) Object provided default_constructor(obj, order) Object default Range.subquery(Query.from(obj)) Parameters: Name Type Argument Default Description obj Range~AnyValue value default_constructor function &lt;optional&gt; Range.equals constructor to use if Param or Comparable is provided order Range~OrderingFunction &lt;optional&gt; DEFAULT_ORDER compare two values and return true if the first is less than the second. Returns: a range Type Range &lt;static&gt; greaterThan(value [, order]) Create a range containing values greater than a given value Parameters: Name Type Argument Default Description value Range~SimpleValue range boundary order Range~OrderingFunction &lt;optional&gt; DEFAULT_ORDER compare two values and return true if the first is less than the second. Returns: a Range object Type Range &lt;static&gt; greaterThanOrEqual(value [, order]) Create a range containing values greater than or equal to a given value Parameters: Name Type Argument Default Description value Range~SimpleValue range boundary order Range~OrderingFunction &lt;optional&gt; DEFAULT_ORDER compare two values and return true if the first is less than the second. Returns: a Range object Type Range &lt;static&gt; isRange(obj) Check to see if an object is a Range Parameters: Name Type Description obj object to check. Returns: true if obj has operator, contains, and intersect properties. &lt;static&gt; lessThan(value [, order]) Create a range containing values less than a given value Parameters: Name Type Argument Default Description value Range~SimpleValue range boundary order Range~OrderingFunction &lt;optional&gt; DEFAULT_ORDER compare two values and return true if the first is less than the second. Returns: a Range object Type Range &lt;static&gt; lessThanOrEqual(value [, order]) Create a range containing values less than or equal to a given value Parameters: Name Type Argument Default Description value Range~SimpleValue range boundary order Range~OrderingFunction &lt;optional&gt; DEFAULT_ORDER compare two values and return true if the first is less than the second. Returns: a Range object Type Range &lt;static&gt; subquery(query) Create a range with a subquery Objects we are querying may be complex. Where an object property contains an object or an array, we may what to execute a subquery on data contained by that object or array in order to determine if the origninal high-level object is matched or not. A trivial case would be a constraint that reads something like: {name : { last: 'Essex'}}to select objects with name.last equal to 'Essex'. This constraint can be constructed with: { name: Range.subquery(Query.from({ last: Range.equals('Essex') } ) ) }However Range.from({last: 'Essex'}) should in most cases do the right thing more succinctly. Parameters: Name Type Description query Query Subquery (which must select data for this range criterion to be satisfied) Returns: a Range object Type Range Type Definitions AnyValue Anything that can be converted into a range. Type: Range~BetweenValue | Query Bounds Bounds object An object with a single property key that is one of the operators defined in Range.OPERATORS. The value of the property should be comparable. Type: Object.&lt;string, Range~SimpleValue&gt; OrderingFunction(a, b) Compare two values and return the lesser Parameters: Name Type Description a first value to compare b second value to compare Returns: true if a &lt; b Type boolean SimpleValue A value that can be used as a parameter when creating a simple range (e.g. with Range.equals, Range.lessThan, etc) Type: Object | Param | Param~ParamObject × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
